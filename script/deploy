#!/usr/bin/env zsh
set -euo pipefail

CONFIG_FILE=script/input/config.json
components=(
  wm:WM
  repermit:RePermit
  cosigner:Cosigner
  reactor:OrderReactor
  executor:Executor
  refinery:Refinery
)

dex=""
verify=false
args=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -d|--dex)
      [[ $# -lt 2 || -z $2 ]] && { printf 'error: missing dex name\n' >&2; exit 1; }
      dex=${2:l}
      shift 2
      ;;
    -v|--verify)
      verify=true
      shift
      ;;
    *)
      args+=("$1")
      shift
      ;;
  esac
done

salt_for() {
  local key=$1 chain=${CHAIN_ID:-}
  jq -r --arg key "$key" --arg chain "$chain" '
    (."*".salt[$key])
    // (if ($chain | length) > 0 then (.[$chain].salt[$key]) else null end)
    // ""
  ' "$CONFIG_FILE"
}

update_config() {
  local target=$1 address=$2 tmp=$(mktemp)
  if [[ $target == global:* ]]; then
    jq --indent 4 --arg key "${target#global:}" --arg addr "$address" '
      setpath(["*", $key]; $addr)
    ' "$CONFIG_FILE" >"$tmp"
  else
    local chain dex field
    local IFS=':'
    read -r _ chain dex field <<< "$target"
    jq --indent 4 --arg chain "$chain" --arg dex "$dex" --arg field "$field" --arg addr "$address" '
      setpath([$chain, "dex", $dex, $field]; $addr)
    ' "$CONFIG_FILE" >"$tmp"
  fi
  mv "$tmp" "$CONFIG_FILE"
  printf 'Updated %s -> %s\n\n' "$target" "$address"
}

should_update_config() {
  local broadcast=false debug=false arg
  for arg in "${args[@]}"; do
    case $arg in
      --broadcast) broadcast=true ;;
      --resume) broadcast=true ;;
      --debug) debug=true ;;
    esac
  done
  $broadcast && ! $debug
}

run() {
  local salt=$1 script=$2 target=${3:-} contract=${4:-} tmp=$(mktemp) raw_tmp=$(mktemp)
  local load_opts=(-u)
  [[ -n ${CHAIN_ID:-} ]] && load_opts+=(-c "$CHAIN_ID")
  local cmd=(load "${load_opts[@]}" "$CONFIG_FILE" forge script "$script" "${args[@]}" --json)
  if [[ -n $salt && $salt != null ]]; then
    cmd=(env SALT=$salt "${cmd[@]}")
  fi

  if ! "${cmd[@]}" >"$raw_tmp"; then
    cat "$raw_tmp"
    rm -f "$tmp" "$raw_tmp"
    return 1
  fi

  grep -E '^[[:space:]]*[\{\[]' "$raw_tmp" > "$tmp" || true
  rm -f "$raw_tmp"

  jq -r '.logs[]?' "$tmp"
  if [[ -n $target ]]; then
    local address=$(jq -r '.returns[]?.value | select(. != null)' "$tmp" | tail -n1)
    if [[ -n $address ]]; then
      if should_update_config; then
        update_config "$target" "$address"
      else
        printf 'Resolved %s -> %s (dry run; config not updated)\n\n' "$target" "$address"
      fi
    fi
  fi

  rm -f "$tmp"
}

deploy_dex() {
  local dex=$1 chain_id=${CHAIN_ID:-}
  if [[ -z $chain_id ]]; then
    printf 'error: CHAIN_ID is required for -d/--dex\n' >&2
    exit 1
  fi

  local dex_type
  if ! dex_type=$(jq -er --arg chain "$chain_id" --arg dex "$dex" '
      .[$chain].dex[$dex].type
      // error("dex \"" + $dex + "\" is not configured for chain " + $chain)
    ' "$CONFIG_FILE"); then
    exit 1
  fi

  local script adapter_contract
  case ${dex_type%%:*} in
    default)
      script=DeployDefaultExchange
      adapter_contract=DefaultDexAdapter
      ;;
    p2)
      script=DeployP2Exchange
      adapter_contract=P2DexAdapter
      ;;
    paraswap)
      script=DeployParaswapExchange
      adapter_contract=ParaswapDexAdapter
      ;;
    *) printf 'error: unsupported adapter type %s\n' "$dex_type" >&2; exit 1 ;;
  esac

  local adapter_address fee_address
  adapter_address=$(jq -r --arg chain "$chain_id" --arg dex "$dex" '.[$chain].dex[$dex].adapter // ""' "$CONFIG_FILE")
  fee_address=$(jq -r --arg chain "$chain_id" --arg dex "$dex" '.[$chain].dex[$dex].fee // ""' "$CONFIG_FILE")

  if [[ -n $adapter_address ]]; then
    printf 'Adapter already configured for %s on chain %s (%s); skipping deployment\n' "$dex" "$chain_id" "$adapter_address"
  else
    run "" "$script" "dex:${chain_id}:${dex}:adapter" "$adapter_contract"
  fi

  if [[ -n $fee_address ]]; then
    printf 'Fee already configured for %s on chain %s (%s); skipping deployment\n' "$dex" "$chain_id" "$fee_address"
  else
    run "" DeployRefinery "dex:${chain_id}:${dex}:fee" Refinery
  fi
}

verify_contracts() {
  local load_opts=(-u)
  [[ -n ${CHAIN_ID:-} ]] && load_opts+=(-c "$CHAIN_ID")

  typeset -A targets=(
    [repermit]=RePermit
    [executor]=Executor
    [reactor]=OrderReactor
  )

  for key contract in ${(kv)targets}; do
    local env_var=${(U)key}
    local script='addr=${'"${env_var}"':-}; if [[ -z $addr ]]; then printf "warning: env var %s not set; skipping verify for %s\n" '"${env_var}"' '"${contract}"' >&2; exit 0; fi; forge v "$addr" '"${contract}"' "$@"'
    load "${load_opts[@]}" "$CONFIG_FILE" sh -c "$script" _ "${args[@]}"
  done
}

if $verify; then
  verify_contracts
  exit 0
fi

if [[ -n $dex ]]; then
  deploy_dex "$dex"
  exit 0
fi

for entry in "${components[@]}"; do
  IFS=':' read -r key contract <<< "$entry"
  if [[ $key == wm ]]; then
    script=DeployWM
  else
    script="Deploy${(U)key[1,1]}${key[2,-1]}"
  fi
  run "$(salt_for "$key")" "$script" "global:$key" "$contract"
done
